// Packages/com.bpg.aion/Editor/CodeGen/AionSnapshotCodeEmitter.cs
#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEditor.Compilation;
using UnityEngine;

namespace BPG.Aion
{
    /// <summary>
    /// Editor-only snapshot code generator. Scans for [GenerateSaveSnapshot] types and emits strongly-typed
    /// Snapshot DTOs + Capture/Restore methods to Assets/Aion.Generated/*.cs.
    /// </summary>
    internal static class AionSnapshotCodeEmitter
    {
        [InitializeOnLoadMethod]
        private static void OnLoadDomain()
        {
            try { GenerateAll(silent: true); }
            catch (Exception ex) { Debug.LogWarning($"[Aion] Snapshot generation skipped: {ex.Message}"); }
        }

        public static void GenerateAll(bool silent = false)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            var types = TypeCache.GetTypesWithAttribute<GenerateSaveSnapshotAttribute>();
            var outDir = AionEditorPaths.EnsureGeneratedFolder();

            int fileCount = 0;
            foreach (var t in types)
            {
                try
                {
                    if (!t.IsClass) continue;
                    var attr = t.GetCustomAttribute<GenerateSaveSnapshotAttribute>(false)!;

                    var code = EmitForType(t, attr);
                    var path = Path.Combine(outDir, $"{t.FullName!.Replace('.', '_').Replace('+', '_')}_Generated.cs");
                    fileCount += WriteIfChanged(path, code) ? 1 : 0;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[Aion] Failed to generate for type {t.FullName}: {ex}");
                }
            }

            AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);
            sw.Stop();

            if (!silent)
                Debug.Log($"[Aion] Snapshot generation complete. Files written: {fileCount}. Elapsed: {sw.ElapsedMilliseconds} ms.");
        }

        private static bool WriteIfChanged(string path, string content)
        {
            if (File.Exists(path))
            {
                var old = File.ReadAllText(path, Encoding.UTF8);
                if (old == content) return false;
            }
            File.WriteAllText(path, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
            return true;
        }

        private static string EmitForType(Type t, GenerateSaveSnapshotAttribute cfg)
        {
            var ns = string.IsNullOrEmpty(t.Namespace) ? null : t.Namespace;
            var tb = new StringBuilder(4096);

            var snapshotName = string.IsNullOrWhiteSpace(cfg.SnapshotName) ? "Snapshot" : cfg.SnapshotName!;
            var includeNonPublic = cfg.IncludeNonPublic;
            var includeProps = cfg.IncludeProperties;

            var flags = BindingFlags.Instance | BindingFlags.Public | (includeNonPublic ? BindingFlags.NonPublic : 0);

            // Gather members with [SaveField]
            var fields = t.GetFields(flags)
                .Where(f => f.GetCustomAttribute<SaveFieldAttribute>(true) != null)
                .Select(f => new MemberInfoEx(f))
                .ToList();

            List<MemberInfoEx> props = new();
            if (includeProps)
            {
                props = t.GetProperties(flags)
                    .Where(p => p.GetCustomAttribute<SaveFieldAttribute>(true) != null && p.CanRead && p.CanWrite)
                    .Select(p => new MemberInfoEx(p))
                    .ToList();
            }

            var members = fields.Concat(props).ToList();

            // Deterministic ordering: SaveOrder asc, then declaration order (MetadataToken)
            members.Sort((a, b) =>
            {
                var ao = a.Order; var bo = b.Order;
                if (ao != bo) return ao.CompareTo(bo);
                return a.MetadataToken.CompareTo(b.MetadataToken);
            });

            // Build code
            tb.AppendLine("// <auto-generated by Aion Save System>");
            tb.AppendLine("#nullable enable");
            tb.AppendLine("using System;");
            tb.AppendLine("using System.Collections.Generic;");
            tb.AppendLine("using UnityEngine;");

            if (ns != null) tb.AppendLine($"namespace {ns} {{");

            tb.AppendLine($"partial class {t.Name}");
            tb.AppendLine("{");

            // SaveKey property (optional override)
            var keyOverride = t.GetCustomAttribute<GenerateSaveSnapshotAttribute>(false)?.SaveKeyOverride;
            if (!string.IsNullOrWhiteSpace(keyOverride))
            {
                tb.AppendLine("    /// <summary>Generated constant save key override.</summary>");
                tb.AppendLine($"    public string SaveKey => \"{EscapeString(keyOverride!)}\";");
                tb.AppendLine();
            }

            // Nested DTO
            tb.AppendLine("    /// <summary>Generated snapshot DTO.</summary>");
            tb.AppendLine("    [Serializable]");
            tb.AppendLine($"    public class {snapshotName}");
            tb.AppendLine("    {");
            foreach (var m in members)
            {
                tb.AppendLine($"        /// <summary>Snapshot of '{m.Name}'.</summary>");
                tb.AppendLine($"        public {TypeToCSharp(m.Type)} {m.Name};");
            }
            tb.AppendLine("    }");
            tb.AppendLine();

            // CaptureSnapshot
            tb.AppendLine("    /// <summary>Generated capture method (no reflection).</summary>");
            tb.AppendLine("    public object CaptureSnapshot()");
            tb.AppendLine("    {");
            tb.AppendLine($"        var dto = new {snapshotName}();");
            foreach (var m in members)
            {
                string src = $"this.{m.Name}";
                tb.AppendLine($"        dto.{m.Name} = {src};");
            }
            tb.AppendLine("        return dto;");
            tb.AppendLine("    }");
            tb.AppendLine();

            // RestoreSnapshot overload (strongly-typed)
            tb.AppendLine("    /// <summary>Generated restore method (no reflection).</summary>");
            tb.AppendLine($"    public void RestoreSnapshot({snapshotName} dto)");
            tb.AppendLine("    {");
            foreach (var m in members)
            {
                string dst = $"this.{m.Name}";
                tb.AppendLine($"        {dst} = dto != null ? dto.{m.Name} : default!;");
            }
            tb.AppendLine("    }");
            tb.AppendLine();

            // RestoreSnapshot(object) shim for runtime reflection callers
            tb.AppendLine("    /// <summary>Generated restore shim that safely handles object input.</summary>");
            tb.AppendLine("    public void RestoreSnapshot(object snapshot)");
            tb.AppendLine("    {");
            tb.AppendLine($"        if (snapshot is {snapshotName} dto)");
            tb.AppendLine("        {");
            tb.AppendLine("            RestoreSnapshot(dto);");
            tb.AppendLine("            return;");
            tb.AppendLine("        }");
            tb.AppendLine("        var got = snapshot != null ? snapshot.GetType().FullName : \"<null>\";");
            tb.AppendLine("        throw new System.InvalidOperationException(\"RestoreSnapshot expected \" + nameof(" + snapshotName + ") + \" but got \" + got + \".\");");
            tb.AppendLine("    }");

            tb.AppendLine("}"); // partial class
            if (ns != null) tb.AppendLine("}"); // namespace

            return tb.ToString();
        }

        private sealed class MemberInfoEx
        {
            public string Name { get; }
            public Type Type { get; }
            public bool IsField { get; }
            public int MetadataToken { get; }
            public int Order { get; }

            public MemberInfoEx(FieldInfo f)
            {
                Name = f.Name;
                Type = f.FieldType;
                IsField = true;
                MetadataToken = f.MetadataToken;
                Order = f.GetCustomAttribute<SaveOrderAttribute>(true)?.Order ?? int.MaxValue;
            }

            public MemberInfoEx(PropertyInfo p)
            {
                Name = p.Name;
                Type = p.PropertyType;
                IsField = false;
                MetadataToken = p.MetadataToken;
                Order = p.GetCustomAttribute<SaveOrderAttribute>(true)?.Order ?? int.MaxValue;
            }
        }

        // --- NEW: Kaynak-kod dostu tür yazıcısı ---
        private static string TypeToCSharp(Type t)
        {
            // ByRef -> element type (ref/out) kaynağa yazılmaz
            if (t.IsByRef)
                t = t.GetElementType()!;

            // Dizi
            if (t.IsArray)
                return $"{TypeToCSharp(t.GetElementType()!)}[]";

            // Generic param (T)
            if (t.IsGenericParameter)
                return t.Name;

            // Nullable<T> (süsleme yerine açık yazım tercih: global::System.Nullable<T>)
            if (IsNullableValueType(t, out var underlying))
                return $"global::System.Nullable<{TypeToCSharp(underlying!)}>";

            // Kapalı generic
            if (t.IsGenericType)
            {
                var def = t.GetGenericTypeDefinition();
                var name = def.Name;
                var tick = name.IndexOf('`');
                if (tick >= 0) name = name.Substring(0, tick);

                var ns = def.Namespace;
                // İç içe türler için dış tip zinciri
                var owner = def.DeclaringType != null ? DeclaringTypeChain(def.DeclaringType) + "." : string.Empty;

                var args = t.GetGenericArguments();
                var argsSrc = string.Join(", ", args.Select(TypeToCSharp));

                return $"global::{(ns != null ? ns + "." : string.Empty)}{owner}{name}<{argsSrc}>";
            }

            // İlkel/özel adlar
            if (PrimitiveKeyword(t, out var kw))
                return kw;

            // İç içe tür
            if (t.IsNested && t.DeclaringType != null)
                return $"global::{t.DeclaringType.Namespace}.{DeclaringTypeChain(t.DeclaringType)}.{t.Name}";

            // Düz tür
            if (!string.IsNullOrEmpty(t.Namespace))
                return $"global::{t.Namespace}.{t.Name}";

            // İsimsiz namespace vb.
            return $"global::{t.Name}";
        }

        private static bool PrimitiveKeyword(Type t, out string keyword)
        {
            // C# anahtar kelime eşlemeleri
            if (t == typeof(void)) { keyword = "void"; return true; }
            if (t == typeof(bool)) { keyword = "bool"; return true; }
            if (t == typeof(byte)) { keyword = "byte"; return true; }
            if (t == typeof(sbyte)) { keyword = "sbyte"; return true; }
            if (t == typeof(short)) { keyword = "short"; return true; }
            if (t == typeof(ushort)) { keyword = "ushort"; return true; }
            if (t == typeof(int)) { keyword = "int"; return true; }
            if (t == typeof(uint)) { keyword = "uint"; return true; }
            if (t == typeof(long)) { keyword = "long"; return true; }
            if (t == typeof(ulong)) { keyword = "ulong"; return true; }
            if (t == typeof(char)) { keyword = "char"; return true; }
            if (t == typeof(float)) { keyword = "float"; return true; }
            if (t == typeof(double)) { keyword = "double"; return true; }
            if (t == typeof(decimal)) { keyword = "decimal"; return true; }
            if (t == typeof(string)) { keyword = "string"; return true; }
            if (t == typeof(object)) { keyword = "object"; return true; }
            keyword = default!;
            return false;
        }

        private static bool IsNullableValueType(Type t, out Type? underlying)
        {
            underlying = Nullable.GetUnderlyingType(t);
            return underlying != null;
        }

        private static string DeclaringTypeChain(Type t)
        {
            // En dıştan içe "Outer.Inner.MoreInner" üret
            var stack = new Stack<string>();
            var cur = t;
            while (cur != null)
            {
                var n = cur.Name;
                var tick = n.IndexOf('`');
                if (tick >= 0) n = n.Substring(0, tick);
                stack.Push(n);
                cur = cur.DeclaringType;
            }
            return string.Join(".", stack);
        }

        private static string EscapeString(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
