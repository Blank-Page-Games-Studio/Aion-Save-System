// Packages/com.bpg.aion/Editor/CodeGen/AionSnapshotCodeEmitter.cs
#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEditor.Compilation;
using UnityEngine;
using static BPG.Aion.Samples.SampleSaveTarget;

namespace BPG.Aion
{
    /// <summary>
    /// Editor-only snapshot code generator. Scans for [GenerateSaveSnapshot] types and emits strongly-typed
    /// Snapshot DTOs + Capture/Restore methods to Assets/Aion.Generated/*.cs.
    /// </summary>
    internal static class AionSnapshotCodeEmitter
    {
        [InitializeOnLoadMethod]
        private static void OnLoadDomain()
        {
            // Auto-generate on domain reload to keep code in sync
            // Best-effort: avoid noisy writes by comparing content.
            try { GenerateAll(silent: true); }
            catch (Exception ex) { Debug.LogWarning($"[Aion] Snapshot generation skipped: {ex.Message}"); }
        }

        public static void GenerateAll(bool silent = false)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            var types = TypeCache.GetTypesWithAttribute<GenerateSaveSnapshotAttribute>();
            var outDir = AionEditorPaths.EnsureGeneratedFolder();

            int fileCount = 0;
            foreach (var t in types)
            {
                try
                {
                    if (!t.IsClass) continue;
                    // We can't detect 'partial' at runtime; assume user followed instructions.
                    var attr = t.GetCustomAttribute<GenerateSaveSnapshotAttribute>(false)!;

                    var code = EmitForType(t, attr);
                    var path = Path.Combine(outDir, $"{t.FullName!.Replace('.', '_').Replace('+', '_')}_Generated.cs");
                    fileCount += WriteIfChanged(path, code) ? 1 : 0;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[Aion] Failed to generate for type {t.FullName}: {ex}");
                }
            }

            AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);
            sw.Stop();

            if (!silent)
                Debug.Log($"[Aion] Snapshot generation complete. Files written: {fileCount}. Elapsed: {sw.ElapsedMilliseconds} ms.");
        }

        private static bool WriteIfChanged(string path, string content)
        {
            if (File.Exists(path))
            {
                var old = File.ReadAllText(path, Encoding.UTF8);
                if (old == content) return false;
            }
            File.WriteAllText(path, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
            return true;
        }

        private static string EmitForType(Type t, GenerateSaveSnapshotAttribute cfg)
        {
            var ns = string.IsNullOrEmpty(t.Namespace) ? null : t.Namespace;
            var tb = new StringBuilder(4096);

            var snapshotName = string.IsNullOrWhiteSpace(cfg.SnapshotName) ? "Snapshot" : cfg.SnapshotName!;
            var includeNonPublic = cfg.IncludeNonPublic;
            var includeProps = cfg.IncludeProperties;

            var flags = BindingFlags.Instance | BindingFlags.Public | (includeNonPublic ? BindingFlags.NonPublic : 0);

            // Gather members with [SaveField]
            var fields = t.GetFields(flags)
                .Where(f => f.GetCustomAttribute<SaveFieldAttribute>(true) != null)
                .Select(f => new MemberInfoEx(f))
                .ToList();

            List<MemberInfoEx> props = new();
            if (includeProps)
            {
                props = t.GetProperties(flags)
                    .Where(p => p.GetCustomAttribute<SaveFieldAttribute>(true) != null && p.CanRead && p.CanWrite)
                    .Select(p => new MemberInfoEx(p))
                    .ToList();
            }

            var members = fields.Concat(props).ToList();

            // Deterministic ordering: SaveOrder asc, then declaration order (MetadataToken)
            members.Sort((a, b) =>
            {
                var ao = a.Order; var bo = b.Order;
                if (ao != bo) return ao.CompareTo(bo);
                return a.MetadataToken.CompareTo(b.MetadataToken);
            });

            // Build code
            tb.AppendLine("// <auto-generated by Aion Save System>");
            tb.AppendLine("#nullable enable");
            tb.AppendLine("using System;");
            tb.AppendLine("using UnityEngine;");

            if (ns != null) tb.AppendLine($"namespace {ns} {{");

            tb.AppendLine($"partial class {t.Name}");
            tb.AppendLine("{");

            // SaveKey property (optional override)
            var keyOverride = t.GetCustomAttribute<GenerateSaveSnapshotAttribute>(false)?.SaveKeyOverride;
            if (!string.IsNullOrWhiteSpace(keyOverride))
            {
                tb.AppendLine("    /// <summary>Generated constant save key override.</summary>");
                tb.AppendLine($"    public string SaveKey => \"{EscapeString(keyOverride!)}\";");
                tb.AppendLine();
            }

            // Nested DTO
            tb.AppendLine("    /// <summary>Generated snapshot DTO.</summary>");
            tb.AppendLine("    [Serializable]");
            tb.AppendLine($"    public struct {snapshotName}");
            tb.AppendLine("    {");
            foreach (var m in members)
            {
                tb.AppendLine($"        /// <summary>Snapshot of '{m.Name}'.</summary>");
                tb.AppendLine($"        public {TypeToCSharp(m.Type)} {m.Name};");
            }
            tb.AppendLine("    }");
            tb.AppendLine();

            // CaptureSnapshot
            tb.AppendLine("    /// <summary>Generated capture method (no reflection).</summary>");
            tb.AppendLine("    public object CaptureSnapshot()");
            tb.AppendLine("    {");
            tb.AppendLine($"        var dto = new {snapshotName}();");
            foreach (var m in members)
            {
                string src = m.IsField ? $"this.{m.Name}" : $"this.{m.Name}";
                tb.AppendLine($"        dto.{m.Name} = {src};");
            }
            tb.AppendLine("        return dto;");
            tb.AppendLine("    }");
            tb.AppendLine();

            // RestoreSnapshot overload (strongly-typed)
            tb.AppendLine("    /// <summary>Generated restore method (no reflection).</summary>");
            tb.AppendLine($"    public void RestoreSnapshot({snapshotName} dto)");
            tb.AppendLine("    {");
            foreach (var m in members)
            {
                string dst = m.IsField ? $"this.{m.Name}" : $"this.{m.Name}";
                tb.AppendLine($"        {dst} = dto.{m.Name};");
            }
            tb.AppendLine("    }");
            tb.AppendLine();

            // RestoreSnapshot(object) shim for runtime reflection callers
            tb.AppendLine("    /// <summary>Generated restore shim that safely handles object input.</summary>");
            tb.AppendLine("    public void RestoreSnapshot(object snapshot)");
            tb.AppendLine("    {");
            tb.AppendLine($"        if (snapshot is {snapshotName} dto)");
            tb.AppendLine("        {");
            tb.AppendLine("            RestoreSnapshot(dto);");
            tb.AppendLine("            return;");
            tb.AppendLine("        }");
            tb.AppendLine("        var got = snapshot != null ? snapshot.GetType().FullName : \"<null>\";");
            tb.AppendLine("        throw new System.InvalidOperationException(\"RestoreSnapshot expected \" + nameof(" + snapshotName + ") + \" but got \" + got + \".\");");
            tb.AppendLine("    }");



            tb.AppendLine("}"); // partial class
            if (ns != null) tb.AppendLine("}"); // namespace

            return tb.ToString();
        }

        private sealed class MemberInfoEx
        {
            public string Name { get; }
            public Type Type { get; }
            public bool IsField { get; }
            public int MetadataToken { get; }
            public int Order { get; }

            public MemberInfoEx(FieldInfo f)
            {
                Name = f.Name;
                Type = f.FieldType;
                IsField = true;
                MetadataToken = f.MetadataToken;
                Order = f.GetCustomAttribute<SaveOrderAttribute>(true)?.Order ?? int.MaxValue;
            }

            public MemberInfoEx(PropertyInfo p)
            {
                Name = p.Name;
                Type = p.PropertyType;
                IsField = false;
                MetadataToken = p.MetadataToken;
                Order = p.GetCustomAttribute<SaveOrderAttribute>(true)?.Order ?? int.MaxValue;
            }
        }

        private static string TypeToCSharp(Type t)
        {
            // Use global:: and replace nested '+' with '.' to be safe for nested types.
            if (t.IsByRef) t = t.GetElementType()!;
            var n = t.FullName?.Replace('+', '.');
            if (n == null) return "object";
            return $"global::{n}";
        }

        private static string EscapeString(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
